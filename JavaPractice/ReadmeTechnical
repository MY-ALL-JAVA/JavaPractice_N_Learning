:: Java World ::

--------------------------------------------------------------------------------
Java Technical Key Notes & Best Pactices :  :  
--------------------------------------------------------------------------------

This Document Aims @ Studying Java (Mainly Java SE & Java EE)


--
#1 Chapter : 1          Java Fundamentals









_________________________________________________________________________________
TARGETS ::
_________________________________________________________________________________
Working With Open Jdk-x.x.x [Realease On Every 6 Months]
Working with Open Jdk-x.x.x [LTS] [Realease For Every 3 Year]
Working with jshell
Working with Java SE
Working With Java EE
Working With Spring & Spring Boot
Working With Hibernate
Complete The Java SE Documentation
__________________________________________________________________________________






--------------------------------------------------------------------------------
#1  Java Fundamentals ::
-------------------------
Java Is A True Object Oriented Programming Language. 

Below is a list of java primative data type :
int(4 bytes), float(4 bytes), double(8 bytes), char(1byte), long(8 byte), bit(1 byte), byte(8 byte)

important features of java :: Distributed, High Interpreted, Oop, MultiThreaded, Architectural Neutral

OOP Principles :
OOP Allows us to decompose a problem into a number of entities called Object, and then Built Data N Function together around it.
Object : Is an Instance of Class.
    Data Abstraction & Encapsulation
    Polymorphism
    Inheritance
    ...


DataTypes In Java ::
    Primitive
        |   --  Boolean
        |   --  Numeric
        |           |   --  Character
        |           |   --  Integeral
        |                        |   --  Integer (byte, short, int, long)
        |                        |   --  Floating Point (Float, Double)
    NonPrimitive
        |   --  String, Array, etc..


Calling / Invoking ::
    Calling a method refers to - calling it explicitely in a program.
    Invoking a method refers to - Method is get called by JVM, Sometimes is also refered to as Callback.

Description On Simple Java Program :
> The Class Name Should be same name as File Name.
> Class Name Must Starts with a Capital Letter.
> The Code Snippet :: public static void main(String args[]){} is described as follow.
    It is required acess specifier as - public - as needs to acess by the JVM Class, Which is out side the current class.
    The - static - is required as the main() method, needs to be acess without creating an object of the class contains it.
    return type void - referes to the method doesn't return anything
    argument to the main method args[] is of String type, which holds the argument passed to the main program while running the program from the command line.
    However the 0th elemet is the Program name(i.e. class name) itself.

Constructor In Java :
    > Constructor name same as the containing class  name
    > Constructor has no return type, but The Constructor can be thought of as a Code Block, Similiar to static block in java
      & return type is similiar to the class type.
    > Constructor returns the instance of the class.


**
It's illegal to start expression such as declaring variable, while calling a function. the start of such expressin requires a ; terminated syntax
the only nested expression possible is inside, for loop..

Constructor can be overloaed by specifying unique formal parameter.
this - keyword is used to refering to the current object's Properties or Methods.

Garbage Collection :
When no reference to an object is found. that memory occupied with that object is released automatically through garbage collection mechanism.

for the JVM to know that the object is no longer referenced. such instances could be decided @ the time of code compilation.
& the memory occupied by the object is freed automatically

System.gc() - refers to the java garbage collector
System.gc() : The Use of this function is very rare in real practice. this is used to free the memory space explicitely.

Finalize() : method is used to make sure resources such as FileHandler are free before we destroy an object
general syntax :
protected void finalize(){//..}

In Java Programming Language We Have Two Class:
    |
    |--java
    |--Java
They both conveys different purpose.


java.lang.Object :
Is the supper class of all the class available in java.
Constructor Method :: Object()
The Following methods are available inside the Object class
    |
    |-- getClass()
    |-- hashCode()
    |-- equals()
    |-- clone()
    |-- toString()
    |-- notify()
    |-- notifyAll()
    |-- wait()
    |-- finalize()

protected void finalize() throws Throwable

Called by the [garbage collector] [GC] {on an object} when garbage collection determines that there are no more references to the object.
A subclass overrides the finalize method to dispose of system resources or to perform other cleanup.

::
Any class overrides the method, to dispose of system resources such as [FileHandler], [DB Object] & Like..
Before the final cleanup happens by the Garbage collector [ System.gc() ]

The general contract of finalize is that it is invoked if and when the Java[TM] virtual machine [JVM] has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized.
The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded.

For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded.

In Short : A Programmer must free up any resources that is occupied by the particular Object before it is Collected By The Garbage collector


_______
Method Overloading ::
In Java a method can be overloaed with (uniqueness of formal parameter)-
    - Number Of parameter
    - Type Of Parameter
    - Order Of Parameter


______
Type Casting ::
The Type casting is of two type -
    Explicit Type Casting
    Implicit Type Casting

An explicit type casting is done by specifying the type in the bracket like : (float) (int)
implicit type casting is done by the interpreter. in such case be aware about the problem of down casting (see upcasting for more details)

When two data type are compatible with each other then the conversion between then happns 

widening :
When assign a smaller data type to a bigger data type then the widening takes palace, provided the two data type are compatible with each other.
byte->short->int->long->float->double

Narrowing :
When a longer data type is assigned to a smaller data type then Narrowing takes palce.

**
Beaware of Float which is a class {} not a primary type.

**
Passing by reference is not available in java, so you can pass an object, to achive the similiar functionality.
any changes to the member of object will reflect in the passed formal parameter ..,

________
Reccursion :
With Reccursion, a function calls itself.

returning object (Sometimes refered to as coverient variable)

Java acess specifier:
There are 4 types of acess specifier available in java described as below:
    :   public      -   outside the package
    :   default     -   only inside the package
    :   protected   -   only inherited class
    :   private     -   only inside the class defined them

Use Of Static:
Static member of a class could be acessible without creating an object of it.
Methods declared as static have the following restrictions
    they can only call other static methods
    must only acess the static data
    can't refer to "this" o/r "super" any way

______
Array in java :
Array in java implemented as Object, there is a special attribute called as "length" used to determine the length of the array.

________
Null Pointer Exception In Java :

When you declare a reference variable (i.e. an object) you are really creating a pointer to an object.
Consider the following code where you declare a variable of primitive type int:
    int x;
    x = 10;
In this example, the variable x is an int and Java will initialize it to 0 for you.
When you assign it to 10 in the second line your value 10 is written into the memory location pointed to by x.

But, when you try to declare a reference type something different happens. Take the following code:
    Integer num;
    num = new Integer(10);
The first line declares a variable named num, but, it does not contain a primitive value.
Instead, it contains a pointer (because the type is Integer which is a reference type).
Since you did not say as yet what to point to Java sets it to null, meaning "I am pointing at nothing".

In the second line, the new keyword is used to instantiate (or create) an object of type Integer and the pointer variable num is assigned this object.
You can now reference the object using the dereferencing operator . (a dot).

If you attempt to dereference num BEFORE creating the object you get a NullPointerException.
In the most trivial cases, the compiler will catch the problem and let you know that "num may not have been initialized" but sometimes you write code that does not directly create the object.

For instance, you may have a method as follows:
public void doSomething(SomeObject obj) {//do something to obj}

In which case you are not creating the object obj, rather assuming that it was created before the doSomething method was called.
Unfortunately, it is possible to call the method like this:
doSomething(null);
In which case obj is null.
If the method is intended to do something to the passed-in object, it is appropriate to throw the NullPointerException because it's a programmer error and the programmer will need that information for debugging purposes.

Alternatively, there may be cases where the purpose of the method is not solely to operate on the passed in object, and therefore a null parameter may be acceptable.
In this case, you would need to check for a null parameter and behave differently.

You should also explain this in the documentation. For example, doSomething could be written as:
 /**
  * @param obj An optional foo for ____. May be null, in which case 
  *  the result will be ____.
  */
public void doSomething(SomeObject obj) {
    if(obj != null) {
       //do something
    } else {
       //do something else
    }
}







































